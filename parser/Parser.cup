package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;
import compiler.Compiler;
import ast.*;

parser code {: 
  Lexer lexer;
  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }
  public void report_fatal_error(String message, Object info) {
    Compiler.fatalError(message + " (" + info + ")", Compiler.EXIT_PARSING_ERROR);
  }
:};

/* keywords */
terminal INT, DOUBLE, RETURN, IF, ELSE;

/* TODO: add more operators */


/* punctuators */
terminal SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, ASSIGN, PLUS, MUL;
/* numeric literals */
terminal Integer INTCONST;
terminal Double  DOUBLECONST;
/* names */
terminal String IDENT;

/* newly added binary operators */
terminal SUB, DIV, MOD;
terminal PLUS_ASSIGN, SUB_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN;


non terminal Program program;
non terminal List<Decl> declList;
non terminal Decl decl;
non terminal List<Integer> arrayDecl;
non terminal List<Stmt> stmtList;
non terminal Stmt stmt;
non terminal Expr expr;
non terminal List<Expr> arrayDim;
non terminal BinaryExpr binaryExpr;

precedence right ASSIGN;
precedence left PLUS;
precedence left MUL;

/* newly added binary operators */
precedence left  SUB, DIV, MOD;
precedence right PLUS_ASSIGN, SUB_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN;


precedence left ELSE; // resolve "dangling else" ambiguity
start with program;

program ::= INT IDENT:i LPAREN RPAREN LBRACE declList:dl stmtList:sl RBRACE
            {: RESULT = new Program(i, Types.INT, dl, sl); :}
          | DOUBLE IDENT:i LPAREN RPAREN LBRACE declList:dl stmtList:sl RBRACE
	    {: RESULT = new Program(i, Types.DOUBLE, dl, sl); :}
;
declList ::= /* empty list */ {: RESULT = new LinkedList<Decl>(); :}
           | decl:d declList:l {: l.add(0,d); RESULT = l; :}
;
decl ::= INT IDENT:i arrayDecl:a SEMICOLON {: RESULT = new Decl(i, Types.INT, a); :} 
       | DOUBLE IDENT:i arrayDecl:a SEMICOLON {: RESULT = new Decl(i, Types. DOUBLE, a); :}
;
arrayDecl ::= /* empty list */ {: RESULT = new LinkedList<Integer>(); :}
            | LBRACK INTCONST:ic RBRACK arrayDecl:a {: a.add(0,ic); RESULT = a; :}
;
stmtList ::= /* empty list */ {: RESULT = new LinkedList<Stmt>(); :}
           | stmt:s stmtList:l  {: l.add(0,s); RESULT = l; :} 
;
stmt ::= expr:e SEMICOLON {: RESULT = new ExprStmt(e); :}
       | RETURN expr:e SEMICOLON {: RESULT = new ReturnStmt(e); :}
       | LBRACE stmtList:l RBRACE {: RESULT = new BlockStmt(l); :}
       | IF LPAREN expr:e RPAREN stmt:s
         {: RESULT = new IfStmt(e, s); :}
       | IF LPAREN expr:e RPAREN stmt:s1 ELSE stmt:s2
         {: RESULT = new IfStmt(e, s1, s2); :}
       | SEMICOLON {: RESULT = new EmptyStmt(); :}
;
expr ::= INTCONST:ic {: RESULT = new IntConstExpr(ic); :}
       | DOUBLECONST:dc {: RESULT = new DoubleConstExpr(dc); :}
       | IDENT:i {: RESULT = new IdentExpr(i); :}
       | IDENT:i arrayDim:a {: RESULT = new ArrayExpr(i, a); :}
       | LPAREN expr:e RPAREN {: RESULT = e; :}
       | binaryExpr:e {: RESULT = e; :}
;
arrayDim ::= LBRACK expr:e RBRACK {: RESULT = new LinkedList<Expr>(); RESULT.add(e); :}
           | LBRACK expr:e RBRACK arrayDim:a {: a.add(0,e); RESULT = a; :}
;
/* TODO: add more operators */
binaryExpr ::= expr:e1 PLUS expr:e2 {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2); :}
             | expr:e1 MUL expr:e2 {: RESULT = new BinaryExpr(e1, BinaryExpr.MUL, e2); :}
             | expr:e1 ASSIGN expr:e2 {: RESULT = new BinaryExpr(e1, BinaryExpr.ASSIGN, e2); :}
             | expr:e1 SUB expr:e2            {: RESULT = new BinaryExpr(e1, BinaryExpr.SUB, e2); :}
             | expr:e1 DIV expr:e2            {: RESULT = new BinaryExpr(e1, BinaryExpr.DIV, e2); :}
             | expr:e1 MOD expr:e2            {: RESULT = new BinaryExpr(e1, BinaryExpr.MOD, e2); :}
             | expr:e1 PLUS_ASSIGN expr:e2    {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS_ASSIGN, e2); :}
             | expr:e1 SUB_ASSIGN expr:e2     {: RESULT = new BinaryExpr(e1, BinaryExpr.SUB_ASSIGN, e2); :}
             | expr:e1 MUL_ASSIGN expr:e2     {: RESULT = new BinaryExpr(e1, BinaryExpr.MUL_ASSIGN, e2); :}
             | expr:e1 DIV_ASSIGN expr:e2     {: RESULT = new BinaryExpr(e1, BinaryExpr.DIV_ASSIGN, e2); :}
             | expr:e1 MOD_ASSIGN expr:e2     {: RESULT = new BinaryExpr(e1, BinaryExpr.MOD_ASSIGN, e2); :}
;


